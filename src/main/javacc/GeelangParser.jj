 /* Calc.jj Adding up numbers */options{  STATIC = false;  LOOKAHEAD= 2;}PARSER_BEGIN(GeelangParser)package com.gtgross.geelang.parser;import com.gtgross.geelang.parser.ast.Node;import com.gtgross.geelang.parser.ast.*;import java.util.List;import java.util.ArrayList;public class GeelangParser{}PARSER_END(GeelangParser)SKIP :{  " "| "\t"}TOKEN :{  < EOL :    "\n"  | "\r"  | "\r\n" >}TOKEN :{  < ADD : "+" >}TOKEN :{  < MINUS : "-" >}TOKEN :{  < TIMES : "*" >}TOKEN :{  < DIVIDE : "/" >}TOKEN :{  < MOD : "%" >}TOKEN :{  < INT : ([ "0"-"9" ])+ >}TOKEN :{  < FLOAT : ([ "0"-"9" ])* "." ([ "0"-"9" ])+ >}TOKEN :{  < MODULE : "module" >}TOKEN :{  < FUNCTION : "func" >}TOKEN :{  < IF : "if" >}TOKEN :{  < ELSE : "else" >}TOKEN :{  < NULL : "null" >}TOKEN :{  < IDENT : [ "_", "A"-"Z", "a"-"z" ] ([ "_", "A"-"Z", "a"-"z", "0"-"9" ])* >}TOKEN :{  < OPEN_PAR : "(" >}TOKEN :{  < CLOSE_PAR : ")" >}TOKEN :{  < OPEN_BRACE : "{" >}TOKEN :{  < CLOSE_BRACE : "}" >}TOKEN :{  < ASSIGN : "=" >}TOKEN :{  < SEMI : ";" >}TOKEN :{  < COMMA : "," >}TOKEN :{  < DOT : "." >}TOKEN :{  < EQ : "==" >}TOKEN :{  < NE : "!=" >}TOKEN :{  < LT : "<" >}TOKEN :{  < LTE : "<=" >}TOKEN :{  < GT : ">" >}TOKEN :{  < GTE : ">=" >}TOKEN :{  < BANG : "!" >}TOKEN :{  < AND : "&" >}TOKEN :{  < OR : "|" >}Node Program() throws NumberFormatException :{  ModuleNode module = null;  List < ModuleNode > modules = new ArrayList < ModuleNode > ();}{  (    module = Module()    {      modules.add(module);    }  )*  < EOF >  {    return new ModuleListNode(modules);  }}ModuleNode Module() throws NumberFormatException :{  Token t;  FunctionListNode functions;}{  < MODULE > t = < IDENT > functions = ModuleBlock()  {    return new ModuleNode(t.image, functions);  }}FunctionListNode ModuleBlock() throws NumberFormatException :{  FunctionNode func;  List < FunctionNode > functions = new ArrayList < FunctionNode > ();}{  < OPEN_BRACE >  (    func = Function()    {      functions.add(func);    }  )*  < CLOSE_BRACE >  {    return new FunctionListNode(functions);  }}FunctionNode Function() throws NumberFormatException :{  Token t;  ParameterListNode params;  StatementListNode body;}{  < FUNCTION > t = < IDENT > < OPEN_PAR > params = ParameterList() < CLOSE_PAR > body = Block()  {    return new FunctionNode(t.image, params, body);  }}ParameterListNode ParameterList() :{  Token t;  List < String > paramsList = new ArrayList < String > ();}{  (    t = < IDENT >    {      paramsList.add(t.image);    }    (      < COMMA > t = < IDENT >      {        paramsList.add(t.image);      }    )*  )?  {    return new ParameterListNode(paramsList);  }}StatementListNode Block() throws NumberFormatException :{  Statement statement;  List < Statement > statements = new ArrayList < Statement > ();}{  < OPEN_BRACE >  (    statement = Statement()    {      statements.add(statement);    }  )*  < CLOSE_BRACE >  {    return new StatementListNode(statements);  }}Statement Statement() throws NumberFormatException :{  Statement stmt;  Expression expr;}{  (    expr = Expression()    {      stmt = expr;    }  )  (    < EOL >  | < SEMI >  )  {    return stmt;  }}Expression Expression() throws NumberFormatException :{  Expression expr;}{  (    expr = AssignExpression()  | expr = IfExpression()  )  {    return expr;  }}Expression AssignExpression() throws NumberFormatException :{  Expression lhs, rhs;}{  lhs = ObjectExpression()  (    < ASSIGN > rhs = ObjectExpression()    {      lhs = new AssignExpression(lhs, rhs);    }  )*  {    return lhs;  }}Expression IfExpression() throws NumberFormatException :{  Expression expr;  StatementListNode trueStmts, falseStmts = null;}{  < IF > expr = ConditionalExpression() trueStmts = Block()  (    < ELSE > falseStmts = Block()  )?  {    return new IfNode(expr, trueStmts, falseStmts);  }}Expression ConditionalExpression() throws NumberFormatException :{  Expression expr, rhs;  Operator op;}{  expr = ObjectExpression()  (    (      < EQ >      {        op = Operator.EQ;      }    | < NE >      {        op = Operator.NE;      }    | < LT >      {        op = Operator.LT;      }    | < LTE >      {        op = Operator.LTE;      }    | < GT >      {        op = Operator.GT;      }    | < GTE >      {        op = Operator.GTE;      }    )    rhs = ObjectExpression()    {      expr = new BinaryOperationNode(op, expr, rhs);    }  )?  {    return expr;  }}Expression ObjectExpression() throws NumberFormatException :{  Expression expr;  ExpressionListNode exprList;  Token t;}{  expr = Factor()  (    exprList = ExpressionList()    {      expr = new FunctionCallNode(expr, exprList);    }  | < DOT > t = < IDENT >    {      if ("new".equals(t.image) && expr instanceof IdentifierNode)      {        expr = new CreateObjectNode(((IdentifierNode) expr).getId());      }      else      {        expr = new ObjectAccessNode(expr, t.image);      }    }  )*  {    return expr;  }}ExpressionListNode ExpressionList() throws NumberFormatException :{  Expression expr;  List < Expression > list = new ArrayList < Expression > ();}{  < OPEN_PAR >  (    expr = Expression()    {      list.add(expr);    }    (      < COMMA > expr = Expression()      {        list.add(expr);      }    )*  )?  < CLOSE_PAR >  {    return new ExpressionListNode(list);  }}Expression Factor() throws NumberFormatException :{  Expression expr1;  Expression expr2 = null;  Operator op = null;}{  expr1 = Term()  (    (      < ADD >      {        op = Operator.ADD;      }    | < MINUS >      {        op = Operator.MINUS;      }    )    expr2 = Term()    {      expr1 = new BinaryOperationNode(op, expr1, expr2);    }  )*  {    return expr1;  }}Expression Term() throws NumberFormatException :{  Expression expr1;  Expression expr2 = null;  Operator op = null;}{  expr1 = Value()  (    (      < TIMES >      {        op = Operator.MULTIPLY;      }    | < DIVIDE >      {        op = Operator.DIVIDE;      }    | < MOD >      {        op = Operator.MODULUS;      }    )    expr2 = Value()    {      expr1 = new BinaryOperationNode(op, expr1, expr2);    }  )*  {    return expr1;  }}Expression Value() throws NumberFormatException :{  Token t;  Expression expr;}{  t = < IDENT >  {    return new IdentifierNode(t.image);  }  | < NULL >  {    return new NullNode();  }| t = < INT >  {    return new IntegerNode(Integer.parseInt(t.image));  }| t = < FLOAT >  {    return new FloatNode(Double.parseDouble(t.image));  }| < OPEN_PAR > expr = Expression() < CLOSE_PAR >  {    return expr;  }| < MINUS > expr = Value()  {    return new UnaryOperationNode(Operator.MINUS, expr);  }| < BANG > expr = ObjectExpression()  {    return new UnaryOperationNode(Operator.NEGATE, expr);  }}
